
----------
2/7/2017 12:10:42 PM 

----------
1. 科大讯飞
	- 介绍一下最近项目中遇到的问题
		- 过车测试数据插入缓慢（规则关掉）
		- 过车数据的下载
			- 单线程-->多线程 前台体验优化
		- 网域的选择
		- ip变化后的对应方案
			- 修复工具
		- 排查到一个问题
			- 添加子系统网域拉取
	- 单点登录原理，单点登出跨域问题，JSONP限制
		- JSONP的跨域请求只能发get请求，且长度有限制
		- jQuery插件解决了出错时不执行error的回调函数问题（由JsonP的实现机制决定）
		- 设置http的头location实现重定向
	- CAS优缺点
		- 同时支持https http
	- 反射原理
	- 动态代理
	- ConcurrentHashMap的实现原理
		- 分段锁，相当于把一个大的Map分成多个HashTable，提升效率
		- 通过key.hashCode确定在哪一个段
	- 分表设计
		- 查询跨表是pg根据分表字段去查询（继承特性）
		- 入库是根据触发器/规则去设计
	- 分代缓存思想
		- 多语言key
	- JVM应用
	- 对于分布式中间件的理解，Kafka的原理配置
	- Tomcat做过哪些优化
	- 如何防止cas的频繁攻击
	- 过车查询跨表是怎样实现的（如一个月的）
	- Http如何加密
	- SOA的理解
	- 使用ActiveMq做过哪些事情，顺带说下它的优缺点
	- 有没有系统设计的经验
	- Protobuf
		- 字段
			- required
			- optional
			- repeated
		- protec  --java_out=*.proto
		- 简洁
		- 体积小：消息大小只需要XML的1/10 ~ 1/3
		- 速度快：解析速度比XML快20-100倍
		- 更好的兼容性
		- 使用Protocol Buffer的编译器，可以生成更容易在编程中使用的数据访问代码


	总结：
	- 紧张
	- 基础再深入一下
	- 项目中的东西熟悉下 

1. 数字政通
	- ReentrantLock
		- JDK1.5后性能与synchronized相近
		- 可重入
			- 可以反复得到同一把锁
		- 可中断
			- lock.lockInterruptibly
			- 中断处理死锁
		- 可限时
			- lock.tryLock(long timeout, TimeUnit unit)
		- 公平锁
			- 先到先得
		- 必须finally释放锁
	- Condition
		- await方法
			- 当前线程等待，且释放锁
			- 其它线程signal/signalAll时或当前线程中断会跳出等待，这与Object.wait方法类似
		- public static ReentrantLock lock = new ReentrantLock();
		- public static Condition condtion = lock.newCondition();
	- Semaphore
		- 共享锁（有次数限制）
			- Semaphore semaphore = new Semaphore(5);
			- public void acquire(int permits)一个线程可申请多个
	- ReadWriteLock
		- private static ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
		- private static Lock readLock = readWriteLock.readLock();
		- private static Lock writeLock = readWriteLock.writeLock();
	- CountDownLatch
		- static final CountDownLatch end = new CountDownLatch(10);
		- end.countDown();
		- end.await();
	- CyclicBarrier
		- 类似CountDownLatch，计数器可重用
	- LockSupport
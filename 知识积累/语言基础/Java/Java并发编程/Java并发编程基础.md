# 第一部分 基础知识

## 第一章 简介

### 1.1 并发简史

- 现实生活场景抽象
  - 寻求异步和同步的平衡点
- 关注点
  - 资源利用
  - 公平性
  - 便利性

### 1.2 线程优势

### 1.3 线程风险

### 1.4 线程无处不在

即使你的程序中从没有显式创建过线程，某些框架可能已经帮你做了这些事情，而且从这些线程调用的代码一定是线程安全的。这从另一个角度向我们展示了对于开发者设计和实现多线程的负担，因为开发线程安全的类比非线程安全的类需要更细心和理性的分析。

每一个Java应用都在使用线程。JVM启动时，会创建一系列线程用于处理JVM管理任务（垃圾清理、对象终结），并创建一个主线程用于运行main方法。AWT和Swing用户交互框架通过创建线程实现管理用户交互接口事件。Timer(定时器)通过创建线程执行延迟的任务。组件框架，比如servlets和RMI创建线程池并调用线程中的组件方法。

如果你使用这些功能（像其他开发人员一样），你必须熟悉并发和线程安全，因为这些框架创建线程并从线程中调用你的组件。如果并发只是一个可选且高级的语言特色就好了，但是现实是几乎所有的Java应用都是多线程的，而且这些框架不会将你从合理协调访问应用的状态中隔离出来。如果框架将并发引入应用中，一般很难控制框架的并发性，因为框架本质上会回调应用组件，这些组件会访问应用状态。同样的，对于线程安全的需要不仅仅局限于框架调用的组件，需要关注所有访问应用程序状态的组件代码路径。因此，对线程安全的需要是会扩散的。

```
框架通过在框架线程中调用应用组件将并发引入到应用中。组件总是会访问应用状态，因此需要访问应用状态的所有代码路径都是线程安全的
```

下面描述的这些功能将会导致应用代码从线程中被调用，而这并不受应用管理。对于线程安全的需求从这些功能开始，但并不从这些功能结束；相反，它会贯穿整个应用。

**定时器** 

定时器是一种方便的延迟任务的调度机制，可以运行一次或定期执行。定时器的引入会使序列化程序变得复杂，因为定制器任务运行在一个受定时器管理的线程中，而不受应用管理。如果定时任务需要访问其他应用线程也在访问的数据，那么它们都需要以线程安全的方式访问数据。最简单的方式是保证被定时任务访问的对象时线程安全的，因此，最简单的方法就是将线程安全封装在共享对象中。

**Servlets和JavaServer Pages(JSPs)**

Servlet设计的初衷是处理发布web应用所需基础设施问题，并分发来自HTTP客户端的请求。到达服务器被分发的请求，可能会通过一个过滤器链，然后到达合适的servlet和JSP。每个servlet表示一个应用程序逻辑组件，在大量访问的网站，多个客户端可能需要同时访问同一个servlet提供的服务。servlet规范要求其可以被多个线程同时访问。换句话说，servlet需要是线程安全的。

即使你可以保证一次只有一个线程调用该servlet，你仍需要在构建web应用的时候关注线程安全。Servlets经常访问其他servlets共享的状态信息，比如应用作用域对象（存储在ServletContext）或者session作用域对象（存储在ServletContext）。当一个servlet访问共享对象（通过servlets或request访问）时，必须协调合理的访问这些共享对象，因为多个请求可能会被多个线程同时访问。Servlets、JSP以及Servlet过滤器和存储在作用域容器（如ServletContext和HttpSession）中的对象，简单来说，必须保证线程安全。

**远程方法调用（Remote Method Invocation）**

RMI允许调用运行在其它虚拟机上的对象方法。当你使用RMI时，方法参数会被打包成字节流并通过网络传输给远程的虚拟机，然后字节流会被解包并传递给远程方法。

当我们使用RMI的时候，它发生在RMI管理的线程，而非你创建的线程。此时会有几个问题？一个是RMI会创建多少线程，同时发生在同一个对象的相同方法的调用是不是在多个RMI线程中执行？

远程对象必须防止两个线程同时访问的安全隐患：合理的协调访问可能被其他对象共享的对象状态，以及合理的协调访问远程对象自身的状态（因为相同对象可能被多个线程同时访问）。与servlet类似，RMI对象也应该支持多个同时调用并且提供其自身的线程安全。

**Swing 和 AWT**

GUI应用本质上就是异步的。用户可能在任何时候选择一个菜单项或者按下一个按钮，并且，他们希望应用及时响应，及时它们正在做其他事情。Swing和AWT会创建一个单独的线程处理用户触发的事件并且更新展示给用户的图像界面。

Swing组件，比如JTable，不是线程安全的。为了实现线程安全，Swing将GUI组件限制到事件线程。如果一个应用想要从事件线程外操作GUI，它一定要调用事件线程中操作GUI的代码来操作运行在事件线程中的GUI。

当用户执行一个UI操作，一个事件线程中的事件处理器被调用以响应用户请求的操作。如果事件处理器访问应用状态（比如文档正在编辑），该状态也被其他线程访问。那么，事件处理器以及其他访问该状态的其他代码一定要以线程安全你的方式来操作。

## 第二章 线程安全

令人惊讶的是，并发编程不仅仅是多线程和锁，就像土木工程不仅仅是铆钉和工字梁。建筑的桥梁不会坍塌需要正确的使用铆钉和工字梁，同理，编写并发程序也需要正确的使用线程和锁。但是，上述这些只是达到目的的一种机制。编写线程安全的代码才是其核心，即管理状态的访问，尤其是共享及易变的状态。

一般，对象的状态就是它的数据，如实例属性或静态属性。一个对象的状态可能包含其他依赖的对象属性；HashMap的状态一部分存储在HasMap对象自身，一部分存储在Map.Entry对象。一个对象的状态包含任何可以影响其外部可见性行为的数据。

共享意味着一个变量可以被多个线程访问；可变意味着变量值在其生命周期中可能会变化。我们讨论线程安全表面上说的是关于代码，但是，我们真正想要表达的是防止数据受到不受控制的并发访问。

一个对象是否需要线程安全取决于它是否在接受多个线程访问。这是一个在程序中如何使用对象的属性，而不是对象它所做的。让一个对象线程安全需要使用同步机制来协调访问它的易变状态；如果不能这样做，则会导致数据损坏和其他未知的结果。









